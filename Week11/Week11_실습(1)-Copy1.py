#!/usr/bin/env python
# coding: utf-8

# # Week 11 데이터 시각화: 예측적 분석 (1)

# -----

# # 국내 프로야구 연봉 예측

# ### 바로가기

# - [<Step1. 탐색> 프로야구 연봉 데이터 살펴보기](#<Step1.-탐색>-프로야구-연봉-데이터-살펴보기)
#     - [프로야구 연봉 데이터셋의 기본 정보]
#     - [회귀 분석에 사용할 피처 살펴보기]
# - [<Step2. 예측> : 투수의 연봉 예측하기](#<Step2.-예측>-:-투수의-연봉-예측하기)
#     - [피처들의 단위 맞춰주기 : 피처 스케일링]
#     - [피처들의 단위 맞춰주기 : one-hot-encoding]
#     - [피처들의 상관관계 분석]
#     - [회귀 분석 적용하기]
# - [<Step3. 평가> : 예측 모델 평가하기](#<Step3.-평가>-:-예측-모델-평가하기)
#     - [어떤 피처가 가장 영향력이 강한 피처일까]
#     - [예측 모델의 평가]
#     - [회귀 분석 예측 성능을 높이기 위한 방법 : 다중 공선성 확인]
#     - [믿을만한 피처로 다시 학습하기]
# - [<Step4. 시각화> : 분석 결과의 시각화](#<Step4.-시각화>-:-분석-결과의-시각화)
#     - [예상 연봉과 실제 연봉 비교]

# -----

# In[1]:


# -*- coding: utf-8 -*-

get_ipython().run_line_magic('matplotlib', 'inline')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

import warnings
warnings.filterwarnings("ignore")


# # <Step1. 탐색> 프로야구 연봉 데이터 살펴보기

# ### [프로야구 연봉 데이터셋의 기본 정보]

# In[2]:


picher_file_path='picher_stats_2017.csv'
batter_file_path='batter_stats_2017.csv'
picher=pd.read_csv(picher_file_path)
batter=pd.read_csv(batter_file_path)


# In[3]:


picher.columns


# In[4]:


picher.head()


# In[5]:


print(picher.shape)


# -----

# ### `[참고 - 한글을 사용하는 그래프]`
# - 파이썬에서 matplotlib 기반의 시각화 툴을 이용할 때 한글 폰트를 사용하는 방법
#     - 자신의 개발환경에 설치된 폰트 확인
#         - `set(sorted([f.name for f in mpl.font_manager.fontManager.ttflist]))`
#     - 한글 폰트를 설정한 뒤, 축에 적용
#         - 예시 :`mpl.rc('font', family='08SeoulHangang')`
#     - 한글 폰트가 없다면, http://hangeul.naver.com/2017/nanum 에서 설치

# In[6]:


import matplotlib as mpl
set(sorted([f.name for f in mpl.font_manager.fontManager.ttflist])) # 현재 OS 내에 설치된 폰트를 확인합니다.


# In[7]:


mpl.rc('font', family='Malgun Gothic') # 자신의 OS에 존재하는 한글 폰트를 선택합니다. 없는경우, 위의 링크에서 한글폰트 설치 후 실행합니다.


# ###### 예측할 대상인 '연봉'에 대한 정보

# In[ ]:





# In[ ]:





# In[ ]:





# - 수십억원대 연봉을 받는 프로선수는 많지 않으며, 5억원 미만의 연봉이 일반적임
# - 기준을 넘어가는 값들이 일부 보임 (Q3+ (1.5* IQR))

# -----

# ### [회귀 분석에 사용할 피처 살펴보기]
#  - 선수명, 팀명과 같이 그래프로 표현할 수 없는 피처들을 제외하고, 모든 수치형 피처의 분포를 살펴보자
#  - 피처들의 분포는 어떠한가? 균형 또는 불균형
#  - 각 피처들의 단워는 같은가 다른가?

# In[ ]:





# In[ ]:





# In[ ]:





# - 피처들은 균일하지 않음
# - 각 피처들의 단위는 다름 (피처들의 단위가 다르다면 예측 모델에서 어떤 문제가 발생할까?)

# -----

# # <Step2. 예측> : 투수의 연봉 예측하기

# ### [피처들의 단위 맞춰주기 : 피처 스케일링]

# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# -----

# ### [피처들의 단위 맞춰주기 : one-hot-encoding]

# - 연속형이 아는 범주형 피처들은 어떻게 정규화할 수 있을까? (원-핫 인코딩)
# - pandas에서는 get_dummies()라는 함수를 통해 원-핫 인코딩을 간단히 수행할 수 있음

# In[ ]:





# In[ ]:





# In[ ]:





# -----

# ### [회귀 분석 적용하기]

# ##### 회귀 분석을 위한 학습, 테스트 데이터셋 분리
#  - random_state: 
#    : scikit learn에서 사용하는 random_state 인자는 수행시마다 동일한 결과를 얻기 위해 적용. train_test_split(..., test_size=0.2) 과 같은 함수는 80% train, 20% test 데이터 세트를 추출. 하지만 추출된 데이터는 수행을 할때마다 다를수 있음. 이는 random하게 80%, 20%를 추출하기 때문임. random_state=1 이라고 하면 바로 이 random 함수의 seed 값을 고정시키기 때문에 여러번 수행하더라도 같은 레코드를 추출함. random 함수의 seed값을 random_state라고 생각하면됨.

# In[ ]:





# ##### 회귀 분석 계수 학습 & 학습된 계수 출력

# In[ ]:





# In[ ]:





# In[ ]:





# -----

# # <Step3. 평가> : 예측 모델 평가하기

# ### [어떤 피처가 가장 영향력이 강한 피처일까]
#  - statsmodel이라는 라이브러리를 이용해보자

# In[8]:


get_ipython().system('pip install statsmodels')


# In[ ]:





# - statmodel에서 OLS(Ordinary Least Squares(최소자승법/최소제곱법) regression)은 linear regression과 동일
# - 결정계수(R-Score), 수정결정계수(Adj. R-Square)의 값을 잘 살펴볼 필요가 있음
#   (이는 회귀분석이 얼마나 잘되었는지 평가하는 지표이며, "회귀 분석으로 추정한 모델이 주어진 데이터를 얼마나 잘 설명하는가?"에 대한 점수임) --> 1에 가까울 수록 데이터를 잘 설명하는 모델 (오차가 적은 모델)
# - F-statistic(F 통계량): 회귀식의 유의성 검정에 사용되는 값 (Prob(F-statisitic): F 통계량의 p-value: 일반적으로 0.05이하면 F통계량이 유의한 의미를 가짐
# - P>|t|: 각 피처의 검정 통계량(t-statistics)의 p-value (마찬가지로 0.05 이하일 때 유의미한 의미를 가짐)
#   (WAR, 연봉(2017), 한화 3개의 피처가 0.05로 나타남)

# In[ ]:





# - 길게 나온것은 영향력인 큰 feature임. 영향력이 크다고 유의미한 feature는 아닐 수 있음
#   (유의미: p-value가 0.05이하인 것)

# -----

# ### [예측 모델의 평가]

# In[ ]:





# In[ ]:





# ##### R2 score

# In[ ]:





# ##### RMSE score

# In[ ]:





# -----

# ### `[미니 퀴즈 - 3.1]`
# - `Train score, 그리고 Test score의 차이점은 무엇일까요? 그리고 어떤 점수가 더 높아야 할까요?` 
#     - 훈련 데이터셋을 통해 계산한 점수와 테스트 데이터셋을 통해 계산한 점수간에는 어떤 차이가 있는 것인지 적어 봅시다. 그리고 이 두 점수의 차이가 크다면, 어떤 상황을 의미하는 것인지 생각해 봅시다.
#         - `대답 예시` : 훈련 데이터셋은 오로지 모델을 학습하고, 비용함수(오차함수)를 평가하는데 사용됩니다. 반면, 테스트 데이터셋은 모델에 영향을 미치지 않습니다. 결과를 예측하기 위한 입력데이터로만 활용됩니다. 가장 이상적인 경우는 Train score, Test score가 차이가 없는 것입니다. 이 차이가 벌어질수록 모델이 훈련 데이터셋에 과적합된 것입니다. 일반적으로는 Train score가 약간 더 높습니다.

# -----

# ### [피처들의 상관관계 분석]

# In[ ]:





# - 승-이닝, kfip-fip, RA9_WAR-WAR 간의 높은 연관성 발견

# -----

# ### [회귀분석 예측 성능을 높이기 위한 방법 : 다중공선성 확인]

# In[ ]:





# - 다중공선성: 회귀분석은 피처간의 독립성을 전제로하는 분석방법임. 상관관계가 높은 피처들을 제거(부정적 영향)
# - VIF(variance inflation fator: 분산팽창요인): VIF 계수가 10-15를 넘으면 다중공선성 문제 발생

# In[ ]:





# -----

# ### `[미니 퀴즈 - 3.2]`
# - `적절한 피처를 선정하여 다시 학습해 보세요.` 
#     - 사용할 피처를 다시 고른 뒤, 다시 학습을 진행했을 때의 Train score, Test score가 어떻게 향상되는지 살펴봅니다.
#         - 아래의 과정을 거쳐 ['FIP', 'WAR', '볼넷/9', '삼진/9', '연봉(2017)'] 피처를 선정했을 때, 더욱 좋은 결과를 나타냈습니다.
#             - 선정 과정
#                 - 1. VIF 계수가 높은 피처들을 우선적으로 제거합니다. 단, (FIP, kFIP)와 같이 유사한 두가지 피처중에는 하나만을 제거합니다.
#                 - 2. 다시 공선성을 검증합니다. 이전 단계에서는 VIF 계수가 높았던 볼넷, 삼진 등의 피처의 VIF 계수가 낮아진 것을 확인할 수 있습니다. VIF 계수가 비정상적으로 높은 피처를 제거해주면, 다른 피처들의 공선성도 자연스레 감소하기 때문입니다.
#                 - 3. 여전히 VIF 계수가 높은 피처들을 제거합니다.
#                 - 4. 남은 피처를 토대로 다시한번 회귀분석을 실시합니다. 분석 결과에서 p-value가 유의하면서도 영향력이 큰 피처들을 선정합니다.
#             - train_score, test_score를 비교했을 때, 기존보다 overfit이 비교적 덜 된것으로 보입니다
#             - test rmse 역시 감소한 것을 볼 수 있습니다.

# ### [적절한 피처로 다시 학습하기]

# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# -----

# # <Step4. 시각화> : 분석 결과의 시각화

# ### [예상 연봉과 실제 연봉 비교]

# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:




